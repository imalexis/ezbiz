// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"ezbiz.com/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"ezbiz.com/ent/entform"
	"ezbiz.com/ent/entformquestion"
	"ezbiz.com/ent/forminstance"
	"ezbiz.com/ent/formspec"
	"ezbiz.com/ent/question"
	"ezbiz.com/ent/questiongroup"
	"ezbiz.com/ent/questionresponse"
	"ezbiz.com/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// EntForm is the client for interacting with the EntForm builders.
	EntForm *EntFormClient
	// EntFormQuestion is the client for interacting with the EntFormQuestion builders.
	EntFormQuestion *EntFormQuestionClient
	// FormInstance is the client for interacting with the FormInstance builders.
	FormInstance *FormInstanceClient
	// FormSpec is the client for interacting with the FormSpec builders.
	FormSpec *FormSpecClient
	// Question is the client for interacting with the Question builders.
	Question *QuestionClient
	// QuestionGroup is the client for interacting with the QuestionGroup builders.
	QuestionGroup *QuestionGroupClient
	// QuestionResponse is the client for interacting with the QuestionResponse builders.
	QuestionResponse *QuestionResponseClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.EntForm = NewEntFormClient(c.config)
	c.EntFormQuestion = NewEntFormQuestionClient(c.config)
	c.FormInstance = NewFormInstanceClient(c.config)
	c.FormSpec = NewFormSpecClient(c.config)
	c.Question = NewQuestionClient(c.config)
	c.QuestionGroup = NewQuestionGroupClient(c.config)
	c.QuestionResponse = NewQuestionResponseClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		EntForm:          NewEntFormClient(cfg),
		EntFormQuestion:  NewEntFormQuestionClient(cfg),
		FormInstance:     NewFormInstanceClient(cfg),
		FormSpec:         NewFormSpecClient(cfg),
		Question:         NewQuestionClient(cfg),
		QuestionGroup:    NewQuestionGroupClient(cfg),
		QuestionResponse: NewQuestionResponseClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		EntForm:          NewEntFormClient(cfg),
		EntFormQuestion:  NewEntFormQuestionClient(cfg),
		FormInstance:     NewFormInstanceClient(cfg),
		FormSpec:         NewFormSpecClient(cfg),
		Question:         NewQuestionClient(cfg),
		QuestionGroup:    NewQuestionGroupClient(cfg),
		QuestionResponse: NewQuestionResponseClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		EntForm.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.EntForm, c.EntFormQuestion, c.FormInstance, c.FormSpec, c.Question,
		c.QuestionGroup, c.QuestionResponse, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.EntForm, c.EntFormQuestion, c.FormInstance, c.FormSpec, c.Question,
		c.QuestionGroup, c.QuestionResponse, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *EntFormMutation:
		return c.EntForm.mutate(ctx, m)
	case *EntFormQuestionMutation:
		return c.EntFormQuestion.mutate(ctx, m)
	case *FormInstanceMutation:
		return c.FormInstance.mutate(ctx, m)
	case *FormSpecMutation:
		return c.FormSpec.mutate(ctx, m)
	case *QuestionMutation:
		return c.Question.mutate(ctx, m)
	case *QuestionGroupMutation:
		return c.QuestionGroup.mutate(ctx, m)
	case *QuestionResponseMutation:
		return c.QuestionResponse.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// EntFormClient is a client for the EntForm schema.
type EntFormClient struct {
	config
}

// NewEntFormClient returns a client for the EntForm from the given config.
func NewEntFormClient(c config) *EntFormClient {
	return &EntFormClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entform.Hooks(f(g(h())))`.
func (c *EntFormClient) Use(hooks ...Hook) {
	c.hooks.EntForm = append(c.hooks.EntForm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entform.Intercept(f(g(h())))`.
func (c *EntFormClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntForm = append(c.inters.EntForm, interceptors...)
}

// Create returns a builder for creating a EntForm entity.
func (c *EntFormClient) Create() *EntFormCreate {
	mutation := newEntFormMutation(c.config, OpCreate)
	return &EntFormCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntForm entities.
func (c *EntFormClient) CreateBulk(builders ...*EntFormCreate) *EntFormCreateBulk {
	return &EntFormCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntFormClient) MapCreateBulk(slice any, setFunc func(*EntFormCreate, int)) *EntFormCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntFormCreateBulk{err: fmt.Errorf("calling to EntFormClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntFormCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntFormCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntForm.
func (c *EntFormClient) Update() *EntFormUpdate {
	mutation := newEntFormMutation(c.config, OpUpdate)
	return &EntFormUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntFormClient) UpdateOne(ef *EntForm) *EntFormUpdateOne {
	mutation := newEntFormMutation(c.config, OpUpdateOne, withEntForm(ef))
	return &EntFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntFormClient) UpdateOneID(id int) *EntFormUpdateOne {
	mutation := newEntFormMutation(c.config, OpUpdateOne, withEntFormID(id))
	return &EntFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntForm.
func (c *EntFormClient) Delete() *EntFormDelete {
	mutation := newEntFormMutation(c.config, OpDelete)
	return &EntFormDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntFormClient) DeleteOne(ef *EntForm) *EntFormDeleteOne {
	return c.DeleteOneID(ef.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntFormClient) DeleteOneID(id int) *EntFormDeleteOne {
	builder := c.Delete().Where(entform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntFormDeleteOne{builder}
}

// Query returns a query builder for EntForm.
func (c *EntFormClient) Query() *EntFormQuery {
	return &EntFormQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntForm},
		inters: c.Interceptors(),
	}
}

// Get returns a EntForm entity by its id.
func (c *EntFormClient) Get(ctx context.Context, id int) (*EntForm, error) {
	return c.Query().Where(entform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntFormClient) GetX(ctx context.Context, id int) *EntForm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestions queries the questions edge of a EntForm.
func (c *EntFormClient) QueryQuestions(ef *EntForm) *EntFormQuestionQuery {
	query := (&EntFormQuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ef.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entform.Table, entform.FieldID, id),
			sqlgraph.To(entformquestion.Table, entformquestion.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, entform.QuestionsTable, entform.QuestionsColumn),
		)
		fromV = sqlgraph.Neighbors(ef.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntFormClient) Hooks() []Hook {
	return c.hooks.EntForm
}

// Interceptors returns the client interceptors.
func (c *EntFormClient) Interceptors() []Interceptor {
	return c.inters.EntForm
}

func (c *EntFormClient) mutate(ctx context.Context, m *EntFormMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntFormCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntFormUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntFormDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntForm mutation op: %q", m.Op())
	}
}

// EntFormQuestionClient is a client for the EntFormQuestion schema.
type EntFormQuestionClient struct {
	config
}

// NewEntFormQuestionClient returns a client for the EntFormQuestion from the given config.
func NewEntFormQuestionClient(c config) *EntFormQuestionClient {
	return &EntFormQuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `entformquestion.Hooks(f(g(h())))`.
func (c *EntFormQuestionClient) Use(hooks ...Hook) {
	c.hooks.EntFormQuestion = append(c.hooks.EntFormQuestion, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `entformquestion.Intercept(f(g(h())))`.
func (c *EntFormQuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.EntFormQuestion = append(c.inters.EntFormQuestion, interceptors...)
}

// Create returns a builder for creating a EntFormQuestion entity.
func (c *EntFormQuestionClient) Create() *EntFormQuestionCreate {
	mutation := newEntFormQuestionMutation(c.config, OpCreate)
	return &EntFormQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EntFormQuestion entities.
func (c *EntFormQuestionClient) CreateBulk(builders ...*EntFormQuestionCreate) *EntFormQuestionCreateBulk {
	return &EntFormQuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EntFormQuestionClient) MapCreateBulk(slice any, setFunc func(*EntFormQuestionCreate, int)) *EntFormQuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EntFormQuestionCreateBulk{err: fmt.Errorf("calling to EntFormQuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EntFormQuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EntFormQuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EntFormQuestion.
func (c *EntFormQuestionClient) Update() *EntFormQuestionUpdate {
	mutation := newEntFormQuestionMutation(c.config, OpUpdate)
	return &EntFormQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EntFormQuestionClient) UpdateOne(efq *EntFormQuestion) *EntFormQuestionUpdateOne {
	mutation := newEntFormQuestionMutation(c.config, OpUpdateOne, withEntFormQuestion(efq))
	return &EntFormQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EntFormQuestionClient) UpdateOneID(id int) *EntFormQuestionUpdateOne {
	mutation := newEntFormQuestionMutation(c.config, OpUpdateOne, withEntFormQuestionID(id))
	return &EntFormQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EntFormQuestion.
func (c *EntFormQuestionClient) Delete() *EntFormQuestionDelete {
	mutation := newEntFormQuestionMutation(c.config, OpDelete)
	return &EntFormQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EntFormQuestionClient) DeleteOne(efq *EntFormQuestion) *EntFormQuestionDeleteOne {
	return c.DeleteOneID(efq.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EntFormQuestionClient) DeleteOneID(id int) *EntFormQuestionDeleteOne {
	builder := c.Delete().Where(entformquestion.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EntFormQuestionDeleteOne{builder}
}

// Query returns a query builder for EntFormQuestion.
func (c *EntFormQuestionClient) Query() *EntFormQuestionQuery {
	return &EntFormQuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEntFormQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a EntFormQuestion entity by its id.
func (c *EntFormQuestionClient) Get(ctx context.Context, id int) (*EntFormQuestion, error) {
	return c.Query().Where(entformquestion.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EntFormQuestionClient) GetX(ctx context.Context, id int) *EntFormQuestion {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryForm queries the form edge of a EntFormQuestion.
func (c *EntFormQuestionClient) QueryForm(efq *EntFormQuestion) *EntFormQuery {
	query := (&EntFormClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := efq.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(entformquestion.Table, entformquestion.FieldID, id),
			sqlgraph.To(entform.Table, entform.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, entformquestion.FormTable, entformquestion.FormColumn),
		)
		fromV = sqlgraph.Neighbors(efq.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EntFormQuestionClient) Hooks() []Hook {
	return c.hooks.EntFormQuestion
}

// Interceptors returns the client interceptors.
func (c *EntFormQuestionClient) Interceptors() []Interceptor {
	return c.inters.EntFormQuestion
}

func (c *EntFormQuestionClient) mutate(ctx context.Context, m *EntFormQuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EntFormQuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EntFormQuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EntFormQuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EntFormQuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EntFormQuestion mutation op: %q", m.Op())
	}
}

// FormInstanceClient is a client for the FormInstance schema.
type FormInstanceClient struct {
	config
}

// NewFormInstanceClient returns a client for the FormInstance from the given config.
func NewFormInstanceClient(c config) *FormInstanceClient {
	return &FormInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `forminstance.Hooks(f(g(h())))`.
func (c *FormInstanceClient) Use(hooks ...Hook) {
	c.hooks.FormInstance = append(c.hooks.FormInstance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `forminstance.Intercept(f(g(h())))`.
func (c *FormInstanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.FormInstance = append(c.inters.FormInstance, interceptors...)
}

// Create returns a builder for creating a FormInstance entity.
func (c *FormInstanceClient) Create() *FormInstanceCreate {
	mutation := newFormInstanceMutation(c.config, OpCreate)
	return &FormInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FormInstance entities.
func (c *FormInstanceClient) CreateBulk(builders ...*FormInstanceCreate) *FormInstanceCreateBulk {
	return &FormInstanceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FormInstanceClient) MapCreateBulk(slice any, setFunc func(*FormInstanceCreate, int)) *FormInstanceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FormInstanceCreateBulk{err: fmt.Errorf("calling to FormInstanceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FormInstanceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FormInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FormInstance.
func (c *FormInstanceClient) Update() *FormInstanceUpdate {
	mutation := newFormInstanceMutation(c.config, OpUpdate)
	return &FormInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FormInstanceClient) UpdateOne(fi *FormInstance) *FormInstanceUpdateOne {
	mutation := newFormInstanceMutation(c.config, OpUpdateOne, withFormInstance(fi))
	return &FormInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FormInstanceClient) UpdateOneID(id int) *FormInstanceUpdateOne {
	mutation := newFormInstanceMutation(c.config, OpUpdateOne, withFormInstanceID(id))
	return &FormInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FormInstance.
func (c *FormInstanceClient) Delete() *FormInstanceDelete {
	mutation := newFormInstanceMutation(c.config, OpDelete)
	return &FormInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FormInstanceClient) DeleteOne(fi *FormInstance) *FormInstanceDeleteOne {
	return c.DeleteOneID(fi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FormInstanceClient) DeleteOneID(id int) *FormInstanceDeleteOne {
	builder := c.Delete().Where(forminstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FormInstanceDeleteOne{builder}
}

// Query returns a query builder for FormInstance.
func (c *FormInstanceClient) Query() *FormInstanceQuery {
	return &FormInstanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFormInstance},
		inters: c.Interceptors(),
	}
}

// Get returns a FormInstance entity by its id.
func (c *FormInstanceClient) Get(ctx context.Context, id int) (*FormInstance, error) {
	return c.Query().Where(forminstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FormInstanceClient) GetX(ctx context.Context, id int) *FormInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFormSpec queries the form_spec edge of a FormInstance.
func (c *FormInstanceClient) QueryFormSpec(fi *FormInstance) *FormSpecQuery {
	query := (&FormSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forminstance.Table, forminstance.FieldID, id),
			sqlgraph.To(formspec.Table, formspec.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, forminstance.FormSpecTable, forminstance.FormSpecColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionResponse queries the question_response edge of a FormInstance.
func (c *FormInstanceClient) QueryQuestionResponse(fi *FormInstance) *QuestionResponseQuery {
	query := (&QuestionResponseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forminstance.Table, forminstance.FieldID, id),
			sqlgraph.To(questionresponse.Table, questionresponse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, forminstance.QuestionResponseTable, forminstance.QuestionResponseColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a FormInstance.
func (c *FormInstanceClient) QueryUsers(fi *FormInstance) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(forminstance.Table, forminstance.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, forminstance.UsersTable, forminstance.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(fi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FormInstanceClient) Hooks() []Hook {
	return c.hooks.FormInstance
}

// Interceptors returns the client interceptors.
func (c *FormInstanceClient) Interceptors() []Interceptor {
	return c.inters.FormInstance
}

func (c *FormInstanceClient) mutate(ctx context.Context, m *FormInstanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FormInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FormInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FormInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FormInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FormInstance mutation op: %q", m.Op())
	}
}

// FormSpecClient is a client for the FormSpec schema.
type FormSpecClient struct {
	config
}

// NewFormSpecClient returns a client for the FormSpec from the given config.
func NewFormSpecClient(c config) *FormSpecClient {
	return &FormSpecClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `formspec.Hooks(f(g(h())))`.
func (c *FormSpecClient) Use(hooks ...Hook) {
	c.hooks.FormSpec = append(c.hooks.FormSpec, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `formspec.Intercept(f(g(h())))`.
func (c *FormSpecClient) Intercept(interceptors ...Interceptor) {
	c.inters.FormSpec = append(c.inters.FormSpec, interceptors...)
}

// Create returns a builder for creating a FormSpec entity.
func (c *FormSpecClient) Create() *FormSpecCreate {
	mutation := newFormSpecMutation(c.config, OpCreate)
	return &FormSpecCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FormSpec entities.
func (c *FormSpecClient) CreateBulk(builders ...*FormSpecCreate) *FormSpecCreateBulk {
	return &FormSpecCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FormSpecClient) MapCreateBulk(slice any, setFunc func(*FormSpecCreate, int)) *FormSpecCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FormSpecCreateBulk{err: fmt.Errorf("calling to FormSpecClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FormSpecCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FormSpecCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FormSpec.
func (c *FormSpecClient) Update() *FormSpecUpdate {
	mutation := newFormSpecMutation(c.config, OpUpdate)
	return &FormSpecUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FormSpecClient) UpdateOne(fs *FormSpec) *FormSpecUpdateOne {
	mutation := newFormSpecMutation(c.config, OpUpdateOne, withFormSpec(fs))
	return &FormSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FormSpecClient) UpdateOneID(id int) *FormSpecUpdateOne {
	mutation := newFormSpecMutation(c.config, OpUpdateOne, withFormSpecID(id))
	return &FormSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FormSpec.
func (c *FormSpecClient) Delete() *FormSpecDelete {
	mutation := newFormSpecMutation(c.config, OpDelete)
	return &FormSpecDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FormSpecClient) DeleteOne(fs *FormSpec) *FormSpecDeleteOne {
	return c.DeleteOneID(fs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FormSpecClient) DeleteOneID(id int) *FormSpecDeleteOne {
	builder := c.Delete().Where(formspec.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FormSpecDeleteOne{builder}
}

// Query returns a query builder for FormSpec.
func (c *FormSpecClient) Query() *FormSpecQuery {
	return &FormSpecQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFormSpec},
		inters: c.Interceptors(),
	}
}

// Get returns a FormSpec entity by its id.
func (c *FormSpecClient) Get(ctx context.Context, id int) (*FormSpec, error) {
	return c.Query().Where(formspec.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FormSpecClient) GetX(ctx context.Context, id int) *FormSpec {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestionGroups queries the question_groups edge of a FormSpec.
func (c *FormSpecClient) QueryQuestionGroups(fs *FormSpec) *QuestionGroupQuery {
	query := (&QuestionGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(formspec.Table, formspec.FieldID, id),
			sqlgraph.To(questiongroup.Table, questiongroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, formspec.QuestionGroupsTable, formspec.QuestionGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(fs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFormInstances queries the form_instances edge of a FormSpec.
func (c *FormSpecClient) QueryFormInstances(fs *FormSpec) *FormInstanceQuery {
	query := (&FormInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(formspec.Table, formspec.FieldID, id),
			sqlgraph.To(forminstance.Table, forminstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, formspec.FormInstancesTable, formspec.FormInstancesColumn),
		)
		fromV = sqlgraph.Neighbors(fs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a FormSpec.
func (c *FormSpecClient) QueryOwner(fs *FormSpec) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(formspec.Table, formspec.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, formspec.OwnerTable, formspec.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(fs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FormSpecClient) Hooks() []Hook {
	return c.hooks.FormSpec
}

// Interceptors returns the client interceptors.
func (c *FormSpecClient) Interceptors() []Interceptor {
	return c.inters.FormSpec
}

func (c *FormSpecClient) mutate(ctx context.Context, m *FormSpecMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FormSpecCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FormSpecUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FormSpecUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FormSpecDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FormSpec mutation op: %q", m.Op())
	}
}

// QuestionClient is a client for the Question schema.
type QuestionClient struct {
	config
}

// NewQuestionClient returns a client for the Question from the given config.
func NewQuestionClient(c config) *QuestionClient {
	return &QuestionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `question.Hooks(f(g(h())))`.
func (c *QuestionClient) Use(hooks ...Hook) {
	c.hooks.Question = append(c.hooks.Question, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `question.Intercept(f(g(h())))`.
func (c *QuestionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Question = append(c.inters.Question, interceptors...)
}

// Create returns a builder for creating a Question entity.
func (c *QuestionClient) Create() *QuestionCreate {
	mutation := newQuestionMutation(c.config, OpCreate)
	return &QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Question entities.
func (c *QuestionClient) CreateBulk(builders ...*QuestionCreate) *QuestionCreateBulk {
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionClient) MapCreateBulk(slice any, setFunc func(*QuestionCreate, int)) *QuestionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionCreateBulk{err: fmt.Errorf("calling to QuestionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Question.
func (c *QuestionClient) Update() *QuestionUpdate {
	mutation := newQuestionMutation(c.config, OpUpdate)
	return &QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionClient) UpdateOne(q *Question) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestion(q))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionClient) UpdateOneID(id int) *QuestionUpdateOne {
	mutation := newQuestionMutation(c.config, OpUpdateOne, withQuestionID(id))
	return &QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Question.
func (c *QuestionClient) Delete() *QuestionDelete {
	mutation := newQuestionMutation(c.config, OpDelete)
	return &QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionClient) DeleteOne(q *Question) *QuestionDeleteOne {
	return c.DeleteOneID(q.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionClient) DeleteOneID(id int) *QuestionDeleteOne {
	builder := c.Delete().Where(question.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionDeleteOne{builder}
}

// Query returns a query builder for Question.
func (c *QuestionClient) Query() *QuestionQuery {
	return &QuestionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestion},
		inters: c.Interceptors(),
	}
}

// Get returns a Question entity by its id.
func (c *QuestionClient) Get(ctx context.Context, id int) (*Question, error) {
	return c.Query().Where(question.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionClient) GetX(ctx context.Context, id int) *Question {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFromQuestionGroup queries the from_question_group edge of a Question.
func (c *QuestionClient) QueryFromQuestionGroup(q *Question) *QuestionGroupQuery {
	query := (&QuestionGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questiongroup.Table, questiongroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, question.FromQuestionGroupTable, question.FromQuestionGroupColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryQuestionResponse queries the question_response edge of a Question.
func (c *QuestionClient) QueryQuestionResponse(q *Question) *QuestionResponseQuery {
	query := (&QuestionResponseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := q.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(question.Table, question.FieldID, id),
			sqlgraph.To(questionresponse.Table, questionresponse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, question.QuestionResponseTable, question.QuestionResponseColumn),
		)
		fromV = sqlgraph.Neighbors(q.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionClient) Hooks() []Hook {
	return c.hooks.Question
}

// Interceptors returns the client interceptors.
func (c *QuestionClient) Interceptors() []Interceptor {
	return c.inters.Question
}

func (c *QuestionClient) mutate(ctx context.Context, m *QuestionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Question mutation op: %q", m.Op())
	}
}

// QuestionGroupClient is a client for the QuestionGroup schema.
type QuestionGroupClient struct {
	config
}

// NewQuestionGroupClient returns a client for the QuestionGroup from the given config.
func NewQuestionGroupClient(c config) *QuestionGroupClient {
	return &QuestionGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questiongroup.Hooks(f(g(h())))`.
func (c *QuestionGroupClient) Use(hooks ...Hook) {
	c.hooks.QuestionGroup = append(c.hooks.QuestionGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questiongroup.Intercept(f(g(h())))`.
func (c *QuestionGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionGroup = append(c.inters.QuestionGroup, interceptors...)
}

// Create returns a builder for creating a QuestionGroup entity.
func (c *QuestionGroupClient) Create() *QuestionGroupCreate {
	mutation := newQuestionGroupMutation(c.config, OpCreate)
	return &QuestionGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionGroup entities.
func (c *QuestionGroupClient) CreateBulk(builders ...*QuestionGroupCreate) *QuestionGroupCreateBulk {
	return &QuestionGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionGroupClient) MapCreateBulk(slice any, setFunc func(*QuestionGroupCreate, int)) *QuestionGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionGroupCreateBulk{err: fmt.Errorf("calling to QuestionGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionGroup.
func (c *QuestionGroupClient) Update() *QuestionGroupUpdate {
	mutation := newQuestionGroupMutation(c.config, OpUpdate)
	return &QuestionGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionGroupClient) UpdateOne(qg *QuestionGroup) *QuestionGroupUpdateOne {
	mutation := newQuestionGroupMutation(c.config, OpUpdateOne, withQuestionGroup(qg))
	return &QuestionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionGroupClient) UpdateOneID(id int) *QuestionGroupUpdateOne {
	mutation := newQuestionGroupMutation(c.config, OpUpdateOne, withQuestionGroupID(id))
	return &QuestionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionGroup.
func (c *QuestionGroupClient) Delete() *QuestionGroupDelete {
	mutation := newQuestionGroupMutation(c.config, OpDelete)
	return &QuestionGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionGroupClient) DeleteOne(qg *QuestionGroup) *QuestionGroupDeleteOne {
	return c.DeleteOneID(qg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionGroupClient) DeleteOneID(id int) *QuestionGroupDeleteOne {
	builder := c.Delete().Where(questiongroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionGroupDeleteOne{builder}
}

// Query returns a query builder for QuestionGroup.
func (c *QuestionGroupClient) Query() *QuestionGroupQuery {
	return &QuestionGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionGroup entity by its id.
func (c *QuestionGroupClient) Get(ctx context.Context, id int) (*QuestionGroup, error) {
	return c.Query().Where(questiongroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionGroupClient) GetX(ctx context.Context, id int) *QuestionGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a QuestionGroup.
func (c *QuestionGroupClient) QueryQuestion(qg *QuestionGroup) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questiongroup.Table, questiongroup.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, questiongroup.QuestionTable, questiongroup.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(qg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFormSpec queries the form_spec edge of a QuestionGroup.
func (c *QuestionGroupClient) QueryFormSpec(qg *QuestionGroup) *FormSpecQuery {
	query := (&FormSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questiongroup.Table, questiongroup.FieldID, id),
			sqlgraph.To(formspec.Table, formspec.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questiongroup.FormSpecTable, questiongroup.FormSpecColumn),
		)
		fromV = sqlgraph.Neighbors(qg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionGroupClient) Hooks() []Hook {
	return c.hooks.QuestionGroup
}

// Interceptors returns the client interceptors.
func (c *QuestionGroupClient) Interceptors() []Interceptor {
	return c.inters.QuestionGroup
}

func (c *QuestionGroupClient) mutate(ctx context.Context, m *QuestionGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionGroup mutation op: %q", m.Op())
	}
}

// QuestionResponseClient is a client for the QuestionResponse schema.
type QuestionResponseClient struct {
	config
}

// NewQuestionResponseClient returns a client for the QuestionResponse from the given config.
func NewQuestionResponseClient(c config) *QuestionResponseClient {
	return &QuestionResponseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `questionresponse.Hooks(f(g(h())))`.
func (c *QuestionResponseClient) Use(hooks ...Hook) {
	c.hooks.QuestionResponse = append(c.hooks.QuestionResponse, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `questionresponse.Intercept(f(g(h())))`.
func (c *QuestionResponseClient) Intercept(interceptors ...Interceptor) {
	c.inters.QuestionResponse = append(c.inters.QuestionResponse, interceptors...)
}

// Create returns a builder for creating a QuestionResponse entity.
func (c *QuestionResponseClient) Create() *QuestionResponseCreate {
	mutation := newQuestionResponseMutation(c.config, OpCreate)
	return &QuestionResponseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of QuestionResponse entities.
func (c *QuestionResponseClient) CreateBulk(builders ...*QuestionResponseCreate) *QuestionResponseCreateBulk {
	return &QuestionResponseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *QuestionResponseClient) MapCreateBulk(slice any, setFunc func(*QuestionResponseCreate, int)) *QuestionResponseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &QuestionResponseCreateBulk{err: fmt.Errorf("calling to QuestionResponseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*QuestionResponseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &QuestionResponseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for QuestionResponse.
func (c *QuestionResponseClient) Update() *QuestionResponseUpdate {
	mutation := newQuestionResponseMutation(c.config, OpUpdate)
	return &QuestionResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *QuestionResponseClient) UpdateOne(qr *QuestionResponse) *QuestionResponseUpdateOne {
	mutation := newQuestionResponseMutation(c.config, OpUpdateOne, withQuestionResponse(qr))
	return &QuestionResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *QuestionResponseClient) UpdateOneID(id int) *QuestionResponseUpdateOne {
	mutation := newQuestionResponseMutation(c.config, OpUpdateOne, withQuestionResponseID(id))
	return &QuestionResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for QuestionResponse.
func (c *QuestionResponseClient) Delete() *QuestionResponseDelete {
	mutation := newQuestionResponseMutation(c.config, OpDelete)
	return &QuestionResponseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *QuestionResponseClient) DeleteOne(qr *QuestionResponse) *QuestionResponseDeleteOne {
	return c.DeleteOneID(qr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *QuestionResponseClient) DeleteOneID(id int) *QuestionResponseDeleteOne {
	builder := c.Delete().Where(questionresponse.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &QuestionResponseDeleteOne{builder}
}

// Query returns a query builder for QuestionResponse.
func (c *QuestionResponseClient) Query() *QuestionResponseQuery {
	return &QuestionResponseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeQuestionResponse},
		inters: c.Interceptors(),
	}
}

// Get returns a QuestionResponse entity by its id.
func (c *QuestionResponseClient) Get(ctx context.Context, id int) (*QuestionResponse, error) {
	return c.Query().Where(questionresponse.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *QuestionResponseClient) GetX(ctx context.Context, id int) *QuestionResponse {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryQuestion queries the question edge of a QuestionResponse.
func (c *QuestionResponseClient) QueryQuestion(qr *QuestionResponse) *QuestionQuery {
	query := (&QuestionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionresponse.Table, questionresponse.FieldID, id),
			sqlgraph.To(question.Table, question.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionresponse.QuestionTable, questionresponse.QuestionColumn),
		)
		fromV = sqlgraph.Neighbors(qr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFormInstance queries the form_instance edge of a QuestionResponse.
func (c *QuestionResponseClient) QueryFormInstance(qr *QuestionResponse) *FormInstanceQuery {
	query := (&FormInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := qr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(questionresponse.Table, questionresponse.FieldID, id),
			sqlgraph.To(forminstance.Table, forminstance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, questionresponse.FormInstanceTable, questionresponse.FormInstanceColumn),
		)
		fromV = sqlgraph.Neighbors(qr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *QuestionResponseClient) Hooks() []Hook {
	return c.hooks.QuestionResponse
}

// Interceptors returns the client interceptors.
func (c *QuestionResponseClient) Interceptors() []Interceptor {
	return c.inters.QuestionResponse
}

func (c *QuestionResponseClient) mutate(ctx context.Context, m *QuestionResponseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&QuestionResponseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&QuestionResponseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&QuestionResponseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&QuestionResponseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown QuestionResponse mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFormSpecs queries the form_specs edge of a User.
func (c *UserClient) QueryFormSpecs(u *User) *FormSpecQuery {
	query := (&FormSpecClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(formspec.Table, formspec.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FormSpecsTable, user.FormSpecsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFormInstances queries the form_instances edge of a User.
func (c *UserClient) QueryFormInstances(u *User) *FormInstanceQuery {
	query := (&FormInstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(forminstance.Table, forminstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FormInstancesTable, user.FormInstancesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		EntForm, EntFormQuestion, FormInstance, FormSpec, Question, QuestionGroup,
		QuestionResponse, User []ent.Hook
	}
	inters struct {
		EntForm, EntFormQuestion, FormInstance, FormSpec, Question, QuestionGroup,
		QuestionResponse, User []ent.Interceptor
	}
)
