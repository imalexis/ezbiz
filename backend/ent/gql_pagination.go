// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"ezbiz.com/ent/entform"
	"ezbiz.com/ent/entformquestion"
	"ezbiz.com/ent/forminstance"
	"ezbiz.com/ent/formspec"
	"ezbiz.com/ent/question"
	"ezbiz.com/ent/questiongroup"
	"ezbiz.com/ent/questionresponse"
	"ezbiz.com/ent/user"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// EntFormEdge is the edge representation of EntForm.
type EntFormEdge struct {
	Node   *EntForm `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// EntFormConnection is the connection containing edges to EntForm.
type EntFormConnection struct {
	Edges      []*EntFormEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *EntFormConnection) build(nodes []*EntForm, pager *entformPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntForm
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntForm {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntForm {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntFormEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntFormEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntFormPaginateOption enables pagination customization.
type EntFormPaginateOption func(*entformPager) error

// WithEntFormOrder configures pagination ordering.
func WithEntFormOrder(order *EntFormOrder) EntFormPaginateOption {
	if order == nil {
		order = DefaultEntFormOrder
	}
	o := *order
	return func(pager *entformPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntFormOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntFormFilter configures pagination filter.
func WithEntFormFilter(filter func(*EntFormQuery) (*EntFormQuery, error)) EntFormPaginateOption {
	return func(pager *entformPager) error {
		if filter == nil {
			return errors.New("EntFormQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entformPager struct {
	reverse bool
	order   *EntFormOrder
	filter  func(*EntFormQuery) (*EntFormQuery, error)
}

func newEntFormPager(opts []EntFormPaginateOption, reverse bool) (*entformPager, error) {
	pager := &entformPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntFormOrder
	}
	return pager, nil
}

func (p *entformPager) applyFilter(query *EntFormQuery) (*EntFormQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entformPager) toCursor(ef *EntForm) Cursor {
	return p.order.Field.toCursor(ef)
}

func (p *entformPager) applyCursors(query *EntFormQuery, after, before *Cursor) (*EntFormQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntFormOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entformPager) applyOrder(query *EntFormQuery) *EntFormQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntFormOrder.Field {
		query = query.Order(DefaultEntFormOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entformPager) orderExpr(query *EntFormQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntFormOrder.Field {
			b.Comma().Ident(DefaultEntFormOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntForm.
func (ef *EntFormQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntFormPaginateOption,
) (*EntFormConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntFormPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ef, err = pager.applyFilter(ef); err != nil {
		return nil, err
	}
	conn := &EntFormConnection{Edges: []*EntFormEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ef.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ef, err = pager.applyCursors(ef, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ef.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ef.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ef = pager.applyOrder(ef)
	nodes, err := ef.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntFormOrderField defines the ordering field of EntForm.
type EntFormOrderField struct {
	// Value extracts the ordering value from the given EntForm.
	Value    func(*EntForm) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entform.OrderOption
	toCursor func(*EntForm) Cursor
}

// EntFormOrder defines the ordering of EntForm.
type EntFormOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *EntFormOrderField `json:"field"`
}

// DefaultEntFormOrder is the default ordering of EntForm.
var DefaultEntFormOrder = &EntFormOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntFormOrderField{
		Value: func(ef *EntForm) (ent.Value, error) {
			return ef.ID, nil
		},
		column: entform.FieldID,
		toTerm: entform.ByID,
		toCursor: func(ef *EntForm) Cursor {
			return Cursor{ID: ef.ID}
		},
	},
}

// ToEdge converts EntForm into EntFormEdge.
func (ef *EntForm) ToEdge(order *EntFormOrder) *EntFormEdge {
	if order == nil {
		order = DefaultEntFormOrder
	}
	return &EntFormEdge{
		Node:   ef,
		Cursor: order.Field.toCursor(ef),
	}
}

// EntFormQuestionEdge is the edge representation of EntFormQuestion.
type EntFormQuestionEdge struct {
	Node   *EntFormQuestion `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// EntFormQuestionConnection is the connection containing edges to EntFormQuestion.
type EntFormQuestionConnection struct {
	Edges      []*EntFormQuestionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *EntFormQuestionConnection) build(nodes []*EntFormQuestion, pager *entformquestionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntFormQuestion
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntFormQuestion {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntFormQuestion {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntFormQuestionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntFormQuestionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntFormQuestionPaginateOption enables pagination customization.
type EntFormQuestionPaginateOption func(*entformquestionPager) error

// WithEntFormQuestionOrder configures pagination ordering.
func WithEntFormQuestionOrder(order *EntFormQuestionOrder) EntFormQuestionPaginateOption {
	if order == nil {
		order = DefaultEntFormQuestionOrder
	}
	o := *order
	return func(pager *entformquestionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntFormQuestionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntFormQuestionFilter configures pagination filter.
func WithEntFormQuestionFilter(filter func(*EntFormQuestionQuery) (*EntFormQuestionQuery, error)) EntFormQuestionPaginateOption {
	return func(pager *entformquestionPager) error {
		if filter == nil {
			return errors.New("EntFormQuestionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entformquestionPager struct {
	reverse bool
	order   *EntFormQuestionOrder
	filter  func(*EntFormQuestionQuery) (*EntFormQuestionQuery, error)
}

func newEntFormQuestionPager(opts []EntFormQuestionPaginateOption, reverse bool) (*entformquestionPager, error) {
	pager := &entformquestionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntFormQuestionOrder
	}
	return pager, nil
}

func (p *entformquestionPager) applyFilter(query *EntFormQuestionQuery) (*EntFormQuestionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entformquestionPager) toCursor(efq *EntFormQuestion) Cursor {
	return p.order.Field.toCursor(efq)
}

func (p *entformquestionPager) applyCursors(query *EntFormQuestionQuery, after, before *Cursor) (*EntFormQuestionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEntFormQuestionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *entformquestionPager) applyOrder(query *EntFormQuestionQuery) *EntFormQuestionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEntFormQuestionOrder.Field {
		query = query.Order(DefaultEntFormQuestionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *entformquestionPager) orderExpr(query *EntFormQuestionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntFormQuestionOrder.Field {
			b.Comma().Ident(DefaultEntFormQuestionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntFormQuestion.
func (efq *EntFormQuestionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntFormQuestionPaginateOption,
) (*EntFormQuestionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntFormQuestionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if efq, err = pager.applyFilter(efq); err != nil {
		return nil, err
	}
	conn := &EntFormQuestionConnection{Edges: []*EntFormQuestionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = efq.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if efq, err = pager.applyCursors(efq, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		efq.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := efq.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	efq = pager.applyOrder(efq)
	nodes, err := efq.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EntFormQuestionOrderField defines the ordering field of EntFormQuestion.
type EntFormQuestionOrderField struct {
	// Value extracts the ordering value from the given EntFormQuestion.
	Value    func(*EntFormQuestion) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) entformquestion.OrderOption
	toCursor func(*EntFormQuestion) Cursor
}

// EntFormQuestionOrder defines the ordering of EntFormQuestion.
type EntFormQuestionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *EntFormQuestionOrderField `json:"field"`
}

// DefaultEntFormQuestionOrder is the default ordering of EntFormQuestion.
var DefaultEntFormQuestionOrder = &EntFormQuestionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EntFormQuestionOrderField{
		Value: func(efq *EntFormQuestion) (ent.Value, error) {
			return efq.ID, nil
		},
		column: entformquestion.FieldID,
		toTerm: entformquestion.ByID,
		toCursor: func(efq *EntFormQuestion) Cursor {
			return Cursor{ID: efq.ID}
		},
	},
}

// ToEdge converts EntFormQuestion into EntFormQuestionEdge.
func (efq *EntFormQuestion) ToEdge(order *EntFormQuestionOrder) *EntFormQuestionEdge {
	if order == nil {
		order = DefaultEntFormQuestionOrder
	}
	return &EntFormQuestionEdge{
		Node:   efq,
		Cursor: order.Field.toCursor(efq),
	}
}

// FormInstanceEdge is the edge representation of FormInstance.
type FormInstanceEdge struct {
	Node   *FormInstance `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FormInstanceConnection is the connection containing edges to FormInstance.
type FormInstanceConnection struct {
	Edges      []*FormInstanceEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *FormInstanceConnection) build(nodes []*FormInstance, pager *forminstancePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FormInstance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FormInstance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FormInstance {
			return nodes[i]
		}
	}
	c.Edges = make([]*FormInstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FormInstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FormInstancePaginateOption enables pagination customization.
type FormInstancePaginateOption func(*forminstancePager) error

// WithFormInstanceOrder configures pagination ordering.
func WithFormInstanceOrder(order *FormInstanceOrder) FormInstancePaginateOption {
	if order == nil {
		order = DefaultFormInstanceOrder
	}
	o := *order
	return func(pager *forminstancePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFormInstanceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFormInstanceFilter configures pagination filter.
func WithFormInstanceFilter(filter func(*FormInstanceQuery) (*FormInstanceQuery, error)) FormInstancePaginateOption {
	return func(pager *forminstancePager) error {
		if filter == nil {
			return errors.New("FormInstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type forminstancePager struct {
	reverse bool
	order   *FormInstanceOrder
	filter  func(*FormInstanceQuery) (*FormInstanceQuery, error)
}

func newFormInstancePager(opts []FormInstancePaginateOption, reverse bool) (*forminstancePager, error) {
	pager := &forminstancePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFormInstanceOrder
	}
	return pager, nil
}

func (p *forminstancePager) applyFilter(query *FormInstanceQuery) (*FormInstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *forminstancePager) toCursor(fi *FormInstance) Cursor {
	return p.order.Field.toCursor(fi)
}

func (p *forminstancePager) applyCursors(query *FormInstanceQuery, after, before *Cursor) (*FormInstanceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFormInstanceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *forminstancePager) applyOrder(query *FormInstanceQuery) *FormInstanceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFormInstanceOrder.Field {
		query = query.Order(DefaultFormInstanceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *forminstancePager) orderExpr(query *FormInstanceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFormInstanceOrder.Field {
			b.Comma().Ident(DefaultFormInstanceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FormInstance.
func (fi *FormInstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FormInstancePaginateOption,
) (*FormInstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFormInstancePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fi, err = pager.applyFilter(fi); err != nil {
		return nil, err
	}
	conn := &FormInstanceConnection{Edges: []*FormInstanceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = fi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fi, err = pager.applyCursors(fi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		fi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fi = pager.applyOrder(fi)
	nodes, err := fi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FormInstanceOrderField defines the ordering field of FormInstance.
type FormInstanceOrderField struct {
	// Value extracts the ordering value from the given FormInstance.
	Value    func(*FormInstance) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) forminstance.OrderOption
	toCursor func(*FormInstance) Cursor
}

// FormInstanceOrder defines the ordering of FormInstance.
type FormInstanceOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FormInstanceOrderField `json:"field"`
}

// DefaultFormInstanceOrder is the default ordering of FormInstance.
var DefaultFormInstanceOrder = &FormInstanceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FormInstanceOrderField{
		Value: func(fi *FormInstance) (ent.Value, error) {
			return fi.ID, nil
		},
		column: forminstance.FieldID,
		toTerm: forminstance.ByID,
		toCursor: func(fi *FormInstance) Cursor {
			return Cursor{ID: fi.ID}
		},
	},
}

// ToEdge converts FormInstance into FormInstanceEdge.
func (fi *FormInstance) ToEdge(order *FormInstanceOrder) *FormInstanceEdge {
	if order == nil {
		order = DefaultFormInstanceOrder
	}
	return &FormInstanceEdge{
		Node:   fi,
		Cursor: order.Field.toCursor(fi),
	}
}

// FormSpecEdge is the edge representation of FormSpec.
type FormSpecEdge struct {
	Node   *FormSpec `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// FormSpecConnection is the connection containing edges to FormSpec.
type FormSpecConnection struct {
	Edges      []*FormSpecEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *FormSpecConnection) build(nodes []*FormSpec, pager *formspecPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FormSpec
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FormSpec {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FormSpec {
			return nodes[i]
		}
	}
	c.Edges = make([]*FormSpecEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FormSpecEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FormSpecPaginateOption enables pagination customization.
type FormSpecPaginateOption func(*formspecPager) error

// WithFormSpecOrder configures pagination ordering.
func WithFormSpecOrder(order *FormSpecOrder) FormSpecPaginateOption {
	if order == nil {
		order = DefaultFormSpecOrder
	}
	o := *order
	return func(pager *formspecPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFormSpecOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFormSpecFilter configures pagination filter.
func WithFormSpecFilter(filter func(*FormSpecQuery) (*FormSpecQuery, error)) FormSpecPaginateOption {
	return func(pager *formspecPager) error {
		if filter == nil {
			return errors.New("FormSpecQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type formspecPager struct {
	reverse bool
	order   *FormSpecOrder
	filter  func(*FormSpecQuery) (*FormSpecQuery, error)
}

func newFormSpecPager(opts []FormSpecPaginateOption, reverse bool) (*formspecPager, error) {
	pager := &formspecPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFormSpecOrder
	}
	return pager, nil
}

func (p *formspecPager) applyFilter(query *FormSpecQuery) (*FormSpecQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *formspecPager) toCursor(fs *FormSpec) Cursor {
	return p.order.Field.toCursor(fs)
}

func (p *formspecPager) applyCursors(query *FormSpecQuery, after, before *Cursor) (*FormSpecQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFormSpecOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *formspecPager) applyOrder(query *FormSpecQuery) *FormSpecQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFormSpecOrder.Field {
		query = query.Order(DefaultFormSpecOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *formspecPager) orderExpr(query *FormSpecQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFormSpecOrder.Field {
			b.Comma().Ident(DefaultFormSpecOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FormSpec.
func (fs *FormSpecQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FormSpecPaginateOption,
) (*FormSpecConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFormSpecPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fs, err = pager.applyFilter(fs); err != nil {
		return nil, err
	}
	conn := &FormSpecConnection{Edges: []*FormSpecEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = fs.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fs, err = pager.applyCursors(fs, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		fs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fs.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fs = pager.applyOrder(fs)
	nodes, err := fs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// FormSpecOrderFieldCreatedAt orders FormSpec by created_at.
	FormSpecOrderFieldCreatedAt = &FormSpecOrderField{
		Value: func(fs *FormSpec) (ent.Value, error) {
			return fs.CreatedAt, nil
		},
		column: formspec.FieldCreatedAt,
		toTerm: formspec.ByCreatedAt,
		toCursor: func(fs *FormSpec) Cursor {
			return Cursor{
				ID:    fs.ID,
				Value: fs.CreatedAt,
			}
		},
	}
	// FormSpecOrderFieldUpdatedAt orders FormSpec by updated_at.
	FormSpecOrderFieldUpdatedAt = &FormSpecOrderField{
		Value: func(fs *FormSpec) (ent.Value, error) {
			return fs.UpdatedAt, nil
		},
		column: formspec.FieldUpdatedAt,
		toTerm: formspec.ByUpdatedAt,
		toCursor: func(fs *FormSpec) Cursor {
			return Cursor{
				ID:    fs.ID,
				Value: fs.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f FormSpecOrderField) String() string {
	var str string
	switch f.column {
	case FormSpecOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case FormSpecOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f FormSpecOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *FormSpecOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("FormSpecOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *FormSpecOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *FormSpecOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid FormSpecOrderField", str)
	}
	return nil
}

// FormSpecOrderField defines the ordering field of FormSpec.
type FormSpecOrderField struct {
	// Value extracts the ordering value from the given FormSpec.
	Value    func(*FormSpec) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) formspec.OrderOption
	toCursor func(*FormSpec) Cursor
}

// FormSpecOrder defines the ordering of FormSpec.
type FormSpecOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *FormSpecOrderField `json:"field"`
}

// DefaultFormSpecOrder is the default ordering of FormSpec.
var DefaultFormSpecOrder = &FormSpecOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FormSpecOrderField{
		Value: func(fs *FormSpec) (ent.Value, error) {
			return fs.ID, nil
		},
		column: formspec.FieldID,
		toTerm: formspec.ByID,
		toCursor: func(fs *FormSpec) Cursor {
			return Cursor{ID: fs.ID}
		},
	},
}

// ToEdge converts FormSpec into FormSpecEdge.
func (fs *FormSpec) ToEdge(order *FormSpecOrder) *FormSpecEdge {
	if order == nil {
		order = DefaultFormSpecOrder
	}
	return &FormSpecEdge{
		Node:   fs,
		Cursor: order.Field.toCursor(fs),
	}
}

// QuestionEdge is the edge representation of Question.
type QuestionEdge struct {
	Node   *Question `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// QuestionConnection is the connection containing edges to Question.
type QuestionConnection struct {
	Edges      []*QuestionEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *QuestionConnection) build(nodes []*Question, pager *questionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Question
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Question {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Question {
			return nodes[i]
		}
	}
	c.Edges = make([]*QuestionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &QuestionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// QuestionPaginateOption enables pagination customization.
type QuestionPaginateOption func(*questionPager) error

// WithQuestionOrder configures pagination ordering.
func WithQuestionOrder(order *QuestionOrder) QuestionPaginateOption {
	if order == nil {
		order = DefaultQuestionOrder
	}
	o := *order
	return func(pager *questionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultQuestionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithQuestionFilter configures pagination filter.
func WithQuestionFilter(filter func(*QuestionQuery) (*QuestionQuery, error)) QuestionPaginateOption {
	return func(pager *questionPager) error {
		if filter == nil {
			return errors.New("QuestionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type questionPager struct {
	reverse bool
	order   *QuestionOrder
	filter  func(*QuestionQuery) (*QuestionQuery, error)
}

func newQuestionPager(opts []QuestionPaginateOption, reverse bool) (*questionPager, error) {
	pager := &questionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultQuestionOrder
	}
	return pager, nil
}

func (p *questionPager) applyFilter(query *QuestionQuery) (*QuestionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *questionPager) toCursor(q *Question) Cursor {
	return p.order.Field.toCursor(q)
}

func (p *questionPager) applyCursors(query *QuestionQuery, after, before *Cursor) (*QuestionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultQuestionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *questionPager) applyOrder(query *QuestionQuery) *QuestionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultQuestionOrder.Field {
		query = query.Order(DefaultQuestionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *questionPager) orderExpr(query *QuestionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultQuestionOrder.Field {
			b.Comma().Ident(DefaultQuestionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Question.
func (q *QuestionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...QuestionPaginateOption,
) (*QuestionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newQuestionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if q, err = pager.applyFilter(q); err != nil {
		return nil, err
	}
	conn := &QuestionConnection{Edges: []*QuestionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = q.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if q, err = pager.applyCursors(q, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		q.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := q.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	q = pager.applyOrder(q)
	nodes, err := q.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// QuestionOrderFieldCreatedAt orders Question by created_at.
	QuestionOrderFieldCreatedAt = &QuestionOrderField{
		Value: func(q *Question) (ent.Value, error) {
			return q.CreatedAt, nil
		},
		column: question.FieldCreatedAt,
		toTerm: question.ByCreatedAt,
		toCursor: func(q *Question) Cursor {
			return Cursor{
				ID:    q.ID,
				Value: q.CreatedAt,
			}
		},
	}
	// QuestionOrderFieldUpdatedAt orders Question by updated_at.
	QuestionOrderFieldUpdatedAt = &QuestionOrderField{
		Value: func(q *Question) (ent.Value, error) {
			return q.UpdatedAt, nil
		},
		column: question.FieldUpdatedAt,
		toTerm: question.ByUpdatedAt,
		toCursor: func(q *Question) Cursor {
			return Cursor{
				ID:    q.ID,
				Value: q.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f QuestionOrderField) String() string {
	var str string
	switch f.column {
	case QuestionOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case QuestionOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f QuestionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *QuestionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("QuestionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *QuestionOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *QuestionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid QuestionOrderField", str)
	}
	return nil
}

// QuestionOrderField defines the ordering field of Question.
type QuestionOrderField struct {
	// Value extracts the ordering value from the given Question.
	Value    func(*Question) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) question.OrderOption
	toCursor func(*Question) Cursor
}

// QuestionOrder defines the ordering of Question.
type QuestionOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *QuestionOrderField `json:"field"`
}

// DefaultQuestionOrder is the default ordering of Question.
var DefaultQuestionOrder = &QuestionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &QuestionOrderField{
		Value: func(q *Question) (ent.Value, error) {
			return q.ID, nil
		},
		column: question.FieldID,
		toTerm: question.ByID,
		toCursor: func(q *Question) Cursor {
			return Cursor{ID: q.ID}
		},
	},
}

// ToEdge converts Question into QuestionEdge.
func (q *Question) ToEdge(order *QuestionOrder) *QuestionEdge {
	if order == nil {
		order = DefaultQuestionOrder
	}
	return &QuestionEdge{
		Node:   q,
		Cursor: order.Field.toCursor(q),
	}
}

// QuestionGroupEdge is the edge representation of QuestionGroup.
type QuestionGroupEdge struct {
	Node   *QuestionGroup `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// QuestionGroupConnection is the connection containing edges to QuestionGroup.
type QuestionGroupConnection struct {
	Edges      []*QuestionGroupEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *QuestionGroupConnection) build(nodes []*QuestionGroup, pager *questiongroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *QuestionGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *QuestionGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *QuestionGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*QuestionGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &QuestionGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// QuestionGroupPaginateOption enables pagination customization.
type QuestionGroupPaginateOption func(*questiongroupPager) error

// WithQuestionGroupOrder configures pagination ordering.
func WithQuestionGroupOrder(order *QuestionGroupOrder) QuestionGroupPaginateOption {
	if order == nil {
		order = DefaultQuestionGroupOrder
	}
	o := *order
	return func(pager *questiongroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultQuestionGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithQuestionGroupFilter configures pagination filter.
func WithQuestionGroupFilter(filter func(*QuestionGroupQuery) (*QuestionGroupQuery, error)) QuestionGroupPaginateOption {
	return func(pager *questiongroupPager) error {
		if filter == nil {
			return errors.New("QuestionGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type questiongroupPager struct {
	reverse bool
	order   *QuestionGroupOrder
	filter  func(*QuestionGroupQuery) (*QuestionGroupQuery, error)
}

func newQuestionGroupPager(opts []QuestionGroupPaginateOption, reverse bool) (*questiongroupPager, error) {
	pager := &questiongroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultQuestionGroupOrder
	}
	return pager, nil
}

func (p *questiongroupPager) applyFilter(query *QuestionGroupQuery) (*QuestionGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *questiongroupPager) toCursor(qg *QuestionGroup) Cursor {
	return p.order.Field.toCursor(qg)
}

func (p *questiongroupPager) applyCursors(query *QuestionGroupQuery, after, before *Cursor) (*QuestionGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultQuestionGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *questiongroupPager) applyOrder(query *QuestionGroupQuery) *QuestionGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultQuestionGroupOrder.Field {
		query = query.Order(DefaultQuestionGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *questiongroupPager) orderExpr(query *QuestionGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultQuestionGroupOrder.Field {
			b.Comma().Ident(DefaultQuestionGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to QuestionGroup.
func (qg *QuestionGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...QuestionGroupPaginateOption,
) (*QuestionGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newQuestionGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if qg, err = pager.applyFilter(qg); err != nil {
		return nil, err
	}
	conn := &QuestionGroupConnection{Edges: []*QuestionGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = qg.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if qg, err = pager.applyCursors(qg, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		qg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := qg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	qg = pager.applyOrder(qg)
	nodes, err := qg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// QuestionGroupOrderFieldCreatedAt orders QuestionGroup by created_at.
	QuestionGroupOrderFieldCreatedAt = &QuestionGroupOrderField{
		Value: func(qg *QuestionGroup) (ent.Value, error) {
			return qg.CreatedAt, nil
		},
		column: questiongroup.FieldCreatedAt,
		toTerm: questiongroup.ByCreatedAt,
		toCursor: func(qg *QuestionGroup) Cursor {
			return Cursor{
				ID:    qg.ID,
				Value: qg.CreatedAt,
			}
		},
	}
	// QuestionGroupOrderFieldUpdatedAt orders QuestionGroup by updated_at.
	QuestionGroupOrderFieldUpdatedAt = &QuestionGroupOrderField{
		Value: func(qg *QuestionGroup) (ent.Value, error) {
			return qg.UpdatedAt, nil
		},
		column: questiongroup.FieldUpdatedAt,
		toTerm: questiongroup.ByUpdatedAt,
		toCursor: func(qg *QuestionGroup) Cursor {
			return Cursor{
				ID:    qg.ID,
				Value: qg.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f QuestionGroupOrderField) String() string {
	var str string
	switch f.column {
	case QuestionGroupOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case QuestionGroupOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f QuestionGroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *QuestionGroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("QuestionGroupOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *QuestionGroupOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *QuestionGroupOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid QuestionGroupOrderField", str)
	}
	return nil
}

// QuestionGroupOrderField defines the ordering field of QuestionGroup.
type QuestionGroupOrderField struct {
	// Value extracts the ordering value from the given QuestionGroup.
	Value    func(*QuestionGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) questiongroup.OrderOption
	toCursor func(*QuestionGroup) Cursor
}

// QuestionGroupOrder defines the ordering of QuestionGroup.
type QuestionGroupOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *QuestionGroupOrderField `json:"field"`
}

// DefaultQuestionGroupOrder is the default ordering of QuestionGroup.
var DefaultQuestionGroupOrder = &QuestionGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &QuestionGroupOrderField{
		Value: func(qg *QuestionGroup) (ent.Value, error) {
			return qg.ID, nil
		},
		column: questiongroup.FieldID,
		toTerm: questiongroup.ByID,
		toCursor: func(qg *QuestionGroup) Cursor {
			return Cursor{ID: qg.ID}
		},
	},
}

// ToEdge converts QuestionGroup into QuestionGroupEdge.
func (qg *QuestionGroup) ToEdge(order *QuestionGroupOrder) *QuestionGroupEdge {
	if order == nil {
		order = DefaultQuestionGroupOrder
	}
	return &QuestionGroupEdge{
		Node:   qg,
		Cursor: order.Field.toCursor(qg),
	}
}

// QuestionResponseEdge is the edge representation of QuestionResponse.
type QuestionResponseEdge struct {
	Node   *QuestionResponse `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// QuestionResponseConnection is the connection containing edges to QuestionResponse.
type QuestionResponseConnection struct {
	Edges      []*QuestionResponseEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *QuestionResponseConnection) build(nodes []*QuestionResponse, pager *questionresponsePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *QuestionResponse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *QuestionResponse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *QuestionResponse {
			return nodes[i]
		}
	}
	c.Edges = make([]*QuestionResponseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &QuestionResponseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// QuestionResponsePaginateOption enables pagination customization.
type QuestionResponsePaginateOption func(*questionresponsePager) error

// WithQuestionResponseOrder configures pagination ordering.
func WithQuestionResponseOrder(order *QuestionResponseOrder) QuestionResponsePaginateOption {
	if order == nil {
		order = DefaultQuestionResponseOrder
	}
	o := *order
	return func(pager *questionresponsePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultQuestionResponseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithQuestionResponseFilter configures pagination filter.
func WithQuestionResponseFilter(filter func(*QuestionResponseQuery) (*QuestionResponseQuery, error)) QuestionResponsePaginateOption {
	return func(pager *questionresponsePager) error {
		if filter == nil {
			return errors.New("QuestionResponseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type questionresponsePager struct {
	reverse bool
	order   *QuestionResponseOrder
	filter  func(*QuestionResponseQuery) (*QuestionResponseQuery, error)
}

func newQuestionResponsePager(opts []QuestionResponsePaginateOption, reverse bool) (*questionresponsePager, error) {
	pager := &questionresponsePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultQuestionResponseOrder
	}
	return pager, nil
}

func (p *questionresponsePager) applyFilter(query *QuestionResponseQuery) (*QuestionResponseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *questionresponsePager) toCursor(qr *QuestionResponse) Cursor {
	return p.order.Field.toCursor(qr)
}

func (p *questionresponsePager) applyCursors(query *QuestionResponseQuery, after, before *Cursor) (*QuestionResponseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultQuestionResponseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *questionresponsePager) applyOrder(query *QuestionResponseQuery) *QuestionResponseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultQuestionResponseOrder.Field {
		query = query.Order(DefaultQuestionResponseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *questionresponsePager) orderExpr(query *QuestionResponseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultQuestionResponseOrder.Field {
			b.Comma().Ident(DefaultQuestionResponseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to QuestionResponse.
func (qr *QuestionResponseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...QuestionResponsePaginateOption,
) (*QuestionResponseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newQuestionResponsePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if qr, err = pager.applyFilter(qr); err != nil {
		return nil, err
	}
	conn := &QuestionResponseConnection{Edges: []*QuestionResponseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = qr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if qr, err = pager.applyCursors(qr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		qr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := qr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	qr = pager.applyOrder(qr)
	nodes, err := qr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// QuestionResponseOrderFieldCreatedAt orders QuestionResponse by created_at.
	QuestionResponseOrderFieldCreatedAt = &QuestionResponseOrderField{
		Value: func(qr *QuestionResponse) (ent.Value, error) {
			return qr.CreatedAt, nil
		},
		column: questionresponse.FieldCreatedAt,
		toTerm: questionresponse.ByCreatedAt,
		toCursor: func(qr *QuestionResponse) Cursor {
			return Cursor{
				ID:    qr.ID,
				Value: qr.CreatedAt,
			}
		},
	}
	// QuestionResponseOrderFieldUpdatedAt orders QuestionResponse by updated_at.
	QuestionResponseOrderFieldUpdatedAt = &QuestionResponseOrderField{
		Value: func(qr *QuestionResponse) (ent.Value, error) {
			return qr.UpdatedAt, nil
		},
		column: questionresponse.FieldUpdatedAt,
		toTerm: questionresponse.ByUpdatedAt,
		toCursor: func(qr *QuestionResponse) Cursor {
			return Cursor{
				ID:    qr.ID,
				Value: qr.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f QuestionResponseOrderField) String() string {
	var str string
	switch f.column {
	case QuestionResponseOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case QuestionResponseOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f QuestionResponseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *QuestionResponseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("QuestionResponseOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *QuestionResponseOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *QuestionResponseOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid QuestionResponseOrderField", str)
	}
	return nil
}

// QuestionResponseOrderField defines the ordering field of QuestionResponse.
type QuestionResponseOrderField struct {
	// Value extracts the ordering value from the given QuestionResponse.
	Value    func(*QuestionResponse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) questionresponse.OrderOption
	toCursor func(*QuestionResponse) Cursor
}

// QuestionResponseOrder defines the ordering of QuestionResponse.
type QuestionResponseOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *QuestionResponseOrderField `json:"field"`
}

// DefaultQuestionResponseOrder is the default ordering of QuestionResponse.
var DefaultQuestionResponseOrder = &QuestionResponseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &QuestionResponseOrderField{
		Value: func(qr *QuestionResponse) (ent.Value, error) {
			return qr.ID, nil
		},
		column: questionresponse.FieldID,
		toTerm: questionresponse.ByID,
		toCursor: func(qr *QuestionResponse) Cursor {
			return Cursor{ID: qr.ID}
		},
	},
}

// ToEdge converts QuestionResponse into QuestionResponseEdge.
func (qr *QuestionResponse) ToEdge(order *QuestionResponseOrder) *QuestionResponseEdge {
	if order == nil {
		order = DefaultQuestionResponseOrder
	}
	return &QuestionResponseEdge{
		Node:   qr,
		Cursor: order.Field.toCursor(qr),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case UserOrderFieldUpdatedAt.column:
		str = "UPDATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *UserOrderFieldCreatedAt
	case "UPDATED_AT":
		*f = *UserOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
